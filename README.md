# RISCV_Three_Stage
RISC-V 3 stage in-order pipeline in verilog

This is a simple RISC-V 3-stage pipeline processor buid using RV32I instruction set. Currently the core is not available for production purposes.
This Project has been done under the mentorship of Prof. Joycee Mekie @ IIT Gandhinagar and student mentor Jitesh Sah.  

## Features

1. Three-stage inorder pipeline processor
2. Complete Modular code and separate stages
3. RV32I instruction sets
3. Data forwarding enabled
4. Stalls
5. Catches exception

## Building Toolchains For Ubuntu

Install RV32I toolchains.

    # Ubuntu packages needed:
    sudo apt-get install autoconf automake autotools-dev curl libmpc-dev \
        libmpfr-dev libgmp-dev gawk build-essential bison flex texinfo \
        gperf libtool patchutils bc zlib1g-dev git libexpat1-dev
    
    git clone --recursive https://github.com/riscv/riscv-gnu-toolchain
    cd riscv-gnu-toolchain
    
    mkdir build; cd build
    ../configure --with-arch=rv32im --prefix=/opt/riscv32i
    make -j$(nproc)


## Building Toolchains For Windows
    We will install the xPack GNU RISC-V Embedded GCC binaries for windows using NPM and XPM. 
        # Windows packages needed:
        - Install npm from here https://www.npmjs.com/get-npm
        - npm i xpm
        - xpm install --global @xpack-dev-tools/riscv-none-embed-gcc@latest
            
    After installing the xPack GNU toolchain, add the tool chain to the path. 
    The tool chain can be found at the following path 
      C:\Users\ilg\AppData\Roaming\xPacks\GNU RISC-V Embedded GCC\8.2.1-3.1\bin
    
    
- You are good to go ! Just test if the toolchains are build or not by crosscompiling any c code. 
- For windows, just run riscv-none-embed-gcc in the terminal, to check if the toolchanins are installed. 
- For linux, run riscv-unknown32-elf-gcc 

## Files list

| Folder         | Description                                       |
| -------------- | ------------------------------------------------- |
| mem_generator  | Contains imem and dmem hex files and C code files |
| modules        | Verilog modules for all three stages and pipeline |
| simulation     | Makefile and output files                         |

## Installing Icarus Verilog

    # Ubuntu package needed to run the RTL simulation
    sudo apt install iverilog
    
    or
    # For Windows download and install iverilog from here 
    http://iverilog.icarus.com/
    
## To simulate the C code 
    cd simulation
    make <C code file name>

    Only running make without parameters will get help.

    make
    make addition         simulates the C code for addition
    make sort             simulates the C code for bubble sort
    make negative         simulates the C code for negative number addition
    make fibonacci        simulates the C code for fibonacci series
    make shifting         simulates the C code for shifting of number
    make xor              simulates the C code for xor
    make clean            clean

- **After this step, a pipeline.vcd file will be generated** 
- **To see the waveform of the simulation, run the following command:** 
        
    gtkwave pipeline.vcd

- **To generate the hex file for IMEM and DMEM without simulating run:**

    cd mem_generator
    make <C code file name>

- **The python script included in the imem_dmem folder converts the binary generated by the compiler to hex format**

| Files Generated       | Description                                       |
| --------------------- | ------------------------------------------------- |
| code.elf              | Elf file for the simulated C code                 |
| code.dis              | Disassembly file for the simulated C code         |
| imem.bin              | Binary for the instrcution memory                 |
| imem.hex              | Hex file for instruction memory                   |
| dmem.bin              | Binary for the data memory                        |
| dmem.hex              | Hex file for data memory                          |

## Screnshots

![alt text](https://github.com/adityatripathiiit/RISCV_Three_Stage/blob/master/screenshots/pipeline_overview.png)
![alt text](https://github.com/adityatripathiiit/RISCV_Three_Stage/blob/master/screenshots/stages_function.png)

**Register Forwarding**

When the data value of a register is calculated in a previous instruction and the updated value is used for the next instruction, the problem of data hazard occurs. To overcome this the updated register value is directly transfered from the writeback stage to execute stage.

<img src="https://github.com/adityatripathiiit/RISCV_Three_Stage/blob/master/screenshots/data_forwarding.png" alt="Register Forwarding"> 


**Branch Penalty**

When the branch is taken during the execute stage, it needs to stall the instructions that have been fetched into the pipeline, which causes a delay/stall of two instructions, so the extra cost of the branch is two.

<img src="https://github.com/adityatripathiiit/RISCV_Three_Stage/blob/master/screenshots/branch.png" alt="Branch Penalty">

## C codes used for testing the pipeline

**Fibonacci Sequence**

<img src="https://github.com/adityatripathiiit/RISCV_Three_Stage/blob/master/screenshots/fibonacci_test.png" alt="Fibonacci Sequence">

**Sorting an array**

<img src="https://github.com/adityatripathiiit/RISCV_Three_Stage/blob/master/screenshots/sorting_test.png" alt="Sorting" >

**Addition of two numbers**

<img src="https://github.com/adityatripathiiit/RISCV_Three_Stage/blob/master/screenshots/addition_test.png" alt="Addition">


**Shifting**

<img src="https://github.com/adityatripathiiit/RISCV_Three_Stage/blob/master/screenshots/shifting_test.png" alt="Shifting">

**Negative integers**

<img src="https://github.com/adityatripathiiit/RISCV_Three_Stage/blob/master/screenshots/negative_test.png" alt="Shifting" >


**Waveform for all the wires**

<img src="https://github.com/adityatripathiiit/RISCV_Three_Stage/blob/master/screenshots/wave.png" alt="wave" >

## 

###

## Supported Instruction Set Architecture

<img src="https://github.com/adityatripathiiit/RISCV_Three_Stage/blob/master/design docs/supported_instruction_set.jpg" alt="ISA" >



## Memory Interface

There is a single memory module for both instruction and data memory. Instruction memory is read only while data memory is both read and write.

## Known issues

* An ideal memory has been assumed for this project, i.e. the instruction and data memory are always read/write valid.
* Branch instructions have two stalls which can be reduced to one, to optimise the functioning.
* No overflow handling in ALU operations
